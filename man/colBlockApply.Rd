% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colBlockApply.R
\name{colBlockApply}
\alias{colBlockApply}
\alias{rowBlockApply}
\title{Apply over blocks of columns or rows}
\usage{
colBlockApply(x, FUN, ..., grid = NULL, BPPARAM = getAutoBPPARAM())

rowBlockApply(x, FUN, ..., grid = NULL, BPPARAM = getAutoBPPARAM())
}
\arguments{
\item{x}{A matrix-like object to be split into blocks and looped over.
This can be of any class that respects the matrix contract.}

\item{FUN}{A function that operates on columns or rows in \code{x},
for \code{colBlockApply} and \code{rowBlockApply} respectively.
Ordinary matrices, *gCMatrix or \linkS4class{SparseArraySeed} objects may be passed as the first argument.}

\item{...}{Further arguments to pass to \code{FUN}.}

\item{grid}{An \linkS4class{ArrayGrid} object specifying how \code{x} should be split into blocks.
For \code{colBlockApply} and \code{rowBlockApply}, blocks should consist of consecutive columns and rows, respectively.}

\item{BPPARAM}{A BiocParallelParam object from the \pkg{BiocParallel} package,
specifying how parallelization should be performed across blocks.}
}
\value{
A list of length equal to the number of blocks, 
where each entry is the output of \code{FUN} for the results of processing each the rows/columns in the corresponding block.
}
\description{
Apply a function over blocks of columns or rows using \pkg{DelayedArray}'s block processing mechanism.
}
\details{
This is a wrapper around \code{\link{blockApply}} that is dedicated to looping across rows or columns of \code{x}.
The aim is to provide a simpler interface for the common task of \code{\link{apply}}ing across a matrix,
along with a few modifications to improve efficiency for parallel processing and for natively supported \code{x}.
Note that the fragmentation of \code{x} into blocks is not easily predictable, 
meaning that \code{FUN} should be capable of operating on each row/column independently.
}
\examples{
x <- matrix(runif(10000), ncol=10)
str(colBlockApply(x, colSums))
str(rowBlockApply(x, rowSums))

library(Matrix)
y <- rsparsematrix(10000, 10000, density=0.01)
str(colBlockApply(y, colSums))
str(rowBlockApply(y, rowSums))

library(DelayedArray)
z <- DelayedArray(y) + 1
str(colBlockApply(z, colSums))
str(rowBlockApply(z, rowSums))

# We can also force multiple blocks:
library(BiocParallel)
BPPARAM <- SnowParam(2)
str(colBlockApply(x, colSums, BPPARAM=BPPARAM))
str(rowBlockApply(x, rowSums, BPPARAM=BPPARAM))

}
\seealso{
\code{\link{blockApply}}, for the original \pkg{DelayedArray} implementation.
}
